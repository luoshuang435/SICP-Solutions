回顾1.2.2小节中的过程：
```
(define (count-change amount)
   (cc amount 5))

(define (cc amount kinds-of-coins)
   (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount
                      (- kinds-of-coins 1))
                  (cc (- amount
                         (first-denomination kinds-of-coins))
                      kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
   (cond ((= kinds-of-coins 1) 1)
         ((= kinds-of-coins 2) 5)
         ((= kinds-of-coins 3) 10)
         ((= kinds-of-coins 4) 25)
         ((= kinds-of-coins 5) 50)))

(count-change 11)
;Value: 4
```

当节点分叉时，左侧的子节点有着相同的amount和更小的kinds-of-coins，
右侧子节点的amount值等于父节点的amount值减去最高硬币面值，kinds-of-coins值与父节点相同。

分支结束条件为当amount小于或等于0，或者kinds-of-coins等于0，画出计算过程图如下：

其中白色节点代表结果为0的叶节点，蓝色节点代表结果为1的组成最后答案的叶节点，黄色节点是递归分支上的节点

![image](https://github.com/jiacai2050/sicp/blob/master/exercises/01/img/count-change-diagram.png)

### 空间复杂度
count-change过程也是树形递归，而且在计算某一节点时，只需要保存当前节点之上的那些节点，所以这里的复杂度是`O(n)`

### 时间复杂度
