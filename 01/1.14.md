回顾1.2.2小节中的过程：
```
(define (count-change amount)
   (cc amount 5))

(define (cc amount kinds-of-coins)
   (cond ((= amount 0) 1)
         ((or (< amount 0) (= kinds-of-coins 0)) 0)
         (else (+ (cc amount
                      (- kinds-of-coins 1))
                  (cc (- amount
                         (first-denomination kinds-of-coins))
                      kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
   (cond ((= kinds-of-coins 1) 1)
         ((= kinds-of-coins 2) 5)
         ((= kinds-of-coins 3) 10)
         ((= kinds-of-coins 4) 25)
         ((= kinds-of-coins 5) 50)))

(count-change 11)
;Value: 4
```

当节点分叉时，左侧的子节点有着相同的`amount`和更小的`kinds-of-coins`，
右侧子节点的`amount`值等于父节点的`amount`值减去最高硬币面值，`kinds-of-coins`值与父节点相同。

分支结束条件为当`amount`小于或等于0，或者`kinds-of-coins`等于0，画出计算过程图如下：

其中白色节点代表结果为0的叶节点，蓝色节点代表结果为1的组成最后答案的叶节点，黄色节点是递归分支上的节点

![image](https://github.com/jiacai2050/sicp/blob/master/exercises/01/img/count-change-diagram.png)

### 空间复杂度
`count-change`过程也是树形递归，计算某一节点时，只需要保存当前节点之上的那些节点，所以这里的复杂度是`O(n)`

### 时间复杂度
首先观察一下`kinds-of-coins`等于1时的计算过程，可以看到直到终端节点为止，每次调用`cc`会再产生2次`cc`调用。
![image](https://github.com/luoshuang435/SICP-Solutions/blob/master/01/img/count-change-11-1-diagram.png)

假设`T(n,k)`为`(cc n k)`所需计算步数，那么

               `T(n,1)=2n+1`


